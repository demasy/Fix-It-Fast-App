/**
 * @license
 * Copyright (c) 2014, 2021, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define(["ojs/ojmap","ojs/ojset","ojs/ojeventtarget","ojs/ojlogger"],function(t,e,s,i){"use strict";t=t&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t,e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e;
/**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
class n{constructor(t,e){this.baseDataProvider=t,this.options=e,this._mapJoinAttributes=new Map,this._fks=[],this._transform=[],this._joinDPs=[],this.JoiningAsyncIterable=class{constructor(t,e,s){this._parent=t,this.params=e,this._asyncIterator=s,this[Symbol.asyncIterator]=()=>new this._parent.JoiningAsyncIterator(this._parent,this._asyncIterator,this.params)}},this.JoiningAsyncIterator=class{constructor(t,e,s){this._parent=t,this._baseIterator=e,this._params=s}_fetchNext(){return this._baseIterator.next().then(t=>t)}next(){return this._fetchNext().then(t=>null!=t&&null!=t.value&&null!=this._parent.options?this._parent._joiningData(t.value.data,this._parent.options).then(e=>(t.value.data=e,t)):t)}},this.FetchByKeysResults=class{constructor(t,e,s){this._parent=t,this.fetchParameters=e,this.results=s,this[n._FETCHPARAMETERS]=e,this[n._RESULTS]=s}},this.FetchByOffsetResults=class{constructor(t,e,s,i){this._parent=t,this.fetchParameters=e,this.results=s,this.done=i,this[n._FETCHPARAMETERS]=e,this[n._RESULTS]=s,this[n._DONE]=i}},this.Item=class{constructor(t,e,s){this._parent=t,this.metadata=e,this.data=s,this[n._METADATA]=e,this[n._DATA]=s}},this.ItemMetadata=class{constructor(t,e){this._parent=t,this.key=e,this[n._KEY]=e}},this._getJoinSpec(e)}fetchFirst(t){const e=t;t&&t.attributes?e.attributes=this._seperateBaseJoinAttributes(t):this._mapJoinAttributes=null;const s=this.baseDataProvider.fetchFirst(e);return new this.JoiningAsyncIterable(this,t,s[Symbol.asyncIterator]())}fetchByKeys(e){let s=e;if(e&&e.attributes){const t=this._seperateBaseJoinAttributes(e);s={keys:e.keys,attributes:t,scope:e.scope}}else this._mapJoinAttributes=null;return this.baseDataProvider.fetchByKeys(s).then(s=>{const i=new t;if(null!=s&&null!=s.results){const t=[],n=[],r=[];let a=0;return e.keys.forEach(t=>{r[a]=t,a++}),this._fetchByKeyResultsToArray(s,r,n,t),this._joiningData(t,this.options).then(t=>(a=0,e.keys.forEach(e=>{i.set(e,new this.Item(this,n[a],t[a])),a++}),new this.FetchByKeysResults(this,e,i)))}})}fetchByOffset(t){let e=t;if(t&&t.attributes){e={attributes:this._seperateBaseJoinAttributes(t),clientId:t.clientId,filterCriterion:t.filterCriterion,offset:t.offset,size:t.size,sortCriteria:t.sortCriteria}}else this._mapJoinAttributes=null;return this.baseDataProvider.fetchByOffset(e).then(e=>{if(null!=e.results){const s=[],i=[];for(let t=0;t<e.results.length;t++)s[t]=e.results[t].metadata,i[t]=e.results[t].data;const n=[];return this._joiningData(i,this.options).then(i=>{for(let t=0;t<e.results.length;t++)n[t]=new this.Item(this,s[t],i[t]);return new this.FetchByOffsetResults(this,t,n,e.done)})}})}containsKeys(t){return this.baseDataProvider.containsKeys(t).then(t=>t)}getTotalSize(){return this.baseDataProvider.getTotalSize().then(t=>t)}isEmpty(){return this.baseDataProvider.isEmpty()}getCapability(t){return"sort"===t||"filter"===t?null:this.baseDataProvider.getCapability(t)}createOptimizedKeySet(t){return new e(t)}createOptimizedKeyMap(e){if(e){const s=new t;return e.forEach(function(t,e){s.set(e,t)}),s}return new t}_getJoinSpec(t){const e=t.joins;this._joinAlias=Object.keys(e);for(let t=0;t<this._joinAlias.length;t++){const s=e[this._joinAlias[t]];null!=s?(null!=s.foreignKeyMapping.foreignKey?this._fks[t]=s.foreignKeyMapping.foreignKey:null!=s.foreignKeyMapping.foreignKeys?this._fks[t]=s.foreignKeyMapping.foreignKeys:this._fks[t]=null,null!=s.foreignKeyMapping.transform?this._transform[t]=s.foreignKeyMapping.transform:this._transform[t]=null,this._joinDPs[t]=s.joinedDataProvider):(this._fks[t]=null,this._joinDPs[t]=null)}}_seperateBaseJoinAttributes(t){this._mapJoinAttributes=new Map;const e=t.attributes;let s=0,i=[];for(let t of e){let e,n;t instanceof String||"string"==typeof t?(e=t,n=t):(e=t.name,n=t.attributes);let r=!1;for(let t=0;null!=this._joinAlias&&t<this._joinAlias.length;t++)if(e===this._joinAlias[t]){r=!0;break}if(r)if(this._mapJoinAttributes.has(e)){let t=this._mapJoinAttributes.get(e);null!=n&&(null==t&&(t=[]),t=t.concat(n),this._mapJoinAttributes.set(e,t))}else this._mapJoinAttributes.set(e,n);else i[s]=n,s++}for(let t=0;null!=this._fks&&t<this._fks.length;t++){const e=this._fks[t];i.includes(e)||(e instanceof Array?i=i.concat(e):(i[s]=this._fks[t],s++))}return i}_joiningData(t,e){if(null==t||0==t.length||null==e.joins)return Promise.resolve(t);const s=[],n=[];this._getFKValues(t,this._fks,this._transform,s);for(let t=0;t<this._joinAlias.length;t++){const e=this._joinDPs[t],r=e.getCapability("fetchByKeys");if(null!=r&&"batchLookup"===r.implementation||i.warn(`Warning: The joined data provider named '${this._joinAlias[t]}' does not support 'batchLookup' implementation for FetchByKeysCapability.`),null==e)n[t]=null;else if(null==this._mapJoinAttributes)n[t]=e.fetchByKeys({keys:s[t]});else if(this._mapJoinAttributes.has(this._joinAlias[t])){const i=this._mapJoinAttributes.get(this._joinAlias[t]);n[t]=e.fetchByKeys({keys:s[t],attributes:i})}else n[t]=null}return Promise.all(n).then(e=>{const i=[],n=[];for(let r=0;null!=e&&r<e.length;r++)(null==this._mapJoinAttributes||this._mapJoinAttributes.has(this._joinAlias[r]))&&(this._fetchByKeyResultsToArray(e[r],s[r],i,n),this._assignAliasData(t,this._joinAlias[r],n));return t})}_getFKValues(t,e,s,i){for(let n=0;n<e.length;n++){const r=[];for(let i=0;i<t.length;i++)if(null!=t[i]&&null!=e[n])if(null!=s&&null!=s[n]&&null!=s[n]){const a=new Object;if(e[n]instanceof Array)for(let s of e[n])a[s]=t[i][s];else a[e[n]]=t[i][e[n]];r[i]=s[n](a)}else if(e[n]instanceof Array){r[i]=[];for(let s=0;s<e[n].length;s++)r[i][s]=t[i][e[n][s]]}else r[i]=t[i][e[n]];else r[i]=null;i[n]=r}}_fetchByKeyResultsToArray(t,e,s,i){if(null!=t&&null!=t.results&&0!==t.results.size)for(let n=0;n<e.length;n++){const r=t.results.get(e[n]);null!=r?(s[n]=r.metadata,i[n]=r.data):(s[n]=null,i[n]=null)}}_assignAliasData(t,e,s){for(let i=0;i<t.length;i++)null!=t[i]&&null!=s&&(t[i][e]=s[i])}}return n._REFRESH="refresh",n._MUTATE="mutate",n._ADDEVENTLISTENER="addEventListener",n._DATA="data",n._METADATA="metadata",n._FETCHPARAMETERS="fetchParameters",n._RESULTS="results",n._DONE="done",n._KEY="key",s.EventTargetMixin.applyMixin(n),n});
//# sourceMappingURL=ojjoiningdataprovider.js.map