/**
 * @license
 * Copyright (c) 2014, 2021, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define(["ojs/ojobservable","ojs/ojurlpathadapter","ojs/ojlogger"],function(t,e,r){"use strict";let i,o;e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e;let n=[],s=[];var a=function(){let t=i;const e=[];for(;t;){let r=t._activeState;if(!r){r=t._getPendingState({path:""}),r&&e.push(r);break}e.push({path:r.path||"",params:r.params,pathParams:r.pathParams}),t=t._childRouter}return e};const h=/^{(\w+)}$/;function c(t){const e=t.match(h);if(e)return e[1];throw Error("no path parameter found for segment "+t)}function u(r,n,s){if(n=n||{},this._name="/",this._urlOffset=0,this.beforeStateChange=new t.BehaviorSubject({accept:function(){}}),this.currentState=new t.BehaviorSubject({complete:function(){}}),this._noHistory="skip"===n.history,this._noHistoryOffset=0,this._parentRouter=s,s)this._name=s._name+s._activeState.path+"/",this._urlOffset=s._urlOffset+s._activeState.pathParams.length+1,s._noHistory&&(this._noHistoryOffset=s._noHistoryOffset+s._activeState.pathParams.length+1);else{if(i)throw Error("Only one root CoreRouter instance may exist at a time");i=this,o=n.urlAdapter||new e,this._setupNavigationListener()}this._configure(r)}return u.prototype.reconfigure=function(t,e={path:""}){return this._prepublish(e).then(()=>this._configure(t)).then(()=>this.go(e))},u.prototype._configure=function(t){t&&(this._routes=t.map(function(t){let e=t.path,r=[];if("string"==typeof e){const t=e.split("/");e=t.shift(),r=t.map(c)}const i={path:e,detail:t.detail||{},pathParams:r,redirect:t.redirect};let o=e;if("string"==typeof e)o=new RegExp("^"+e+"$");else if(!(e instanceof RegExp))throw Error("Router path must be a string or RegExp");return i._match=o,Object.freeze(i),i},this))},u.prototype.sync=function(){let t;if(s.length){const e=s.shift(),r=a().slice(0,this._urlOffset).concat(this._getPendingState(e)),i=o.getUrlForRoutes(r);window.history.replaceState(null,"path",i),t=e}else t=this._getRouteSegment();return this._execute(t||{path:"",params:{}}).then(t=>{var e=t,r=this._childRouter;return r?e=r.sync():this._noHistory||(n=[]),e})},u.prototype._getRouteSegment=function(){let t;if(this._noHistory)t=n[this._noHistoryOffset];else{let e=o.getRoutesForUrl();t=e[this._urlOffset];const r=this._getRoutePathParams(t&&t.path);e=o.getRoutesForUrl({offset:this._urlOffset,pathParams:r}),t=e[this._urlOffset]}return t},u.prototype.go=function(){const t=[...arguments];let e;if(t.forEach(function(t){var r=t.params;r&&Object.keys(r).forEach(function(t){"object"==typeof r[t]&&(e=Promise.reject('"params" object may only contain scalar values'))})}),!e){const i=t.map(t=>t.path).join("/");r.info(`Navigating router(${this._name}) to ${i}`);const h=t[0],c=a(),u=o.getUrlForRoutes(c),p=c.slice(0,this._urlOffset).concat(this._getPendingState(h,!0)),f=o.getUrlForRoutes(p);this._noHistory?(r.info(`Navigating non-history tracking router(${this._name}) to ${i}`),n=n.slice(0,this._noHistoryOffset).concat(t)):u!==f&&window.history.pushState(null,"path",f),e=this.sync(),s=t.slice(1)}return e},u.prototype._execute=function(t){const e=this._getPendingState(t);let r;return e?(r=this._prepublish(e),this._isCurrentState(e)||(r=r.then(()=>this._publish(e)))):r=Promise.reject("Router("+this._name+') has no state matching "'+t.path+'"'),r},u.prototype._prepublish=function(t){var e=[];this.beforeStateChange.next({state:t,accept:function(t){e.push(t)}});var n=Promise.all(e).then(function(){return t}),s=this._childRouter;return s&&(n=n.then(function(){return s._prepublish(t)})),n=n.then(function(t){return n!==this._activeSync?Promise.reject():t}.bind(this),function(t){if(n===this._activeSync){r.info("Router sync failed: "+t);var e=function(){for(var t=i,e=[];t;){var r=t._activeState;e.push(r),t=t._childRouter}return o.getUrlForRoutes(e)}();window.history.replaceState(null,"path",e)}return Promise.reject(t)}.bind(this)),this._activeSync=n,n},u.prototype._publish=function(t){var e=[];return this._childRouter=null,this._activeState=t,this.currentState.next({state:t,complete:function(t){e.push(t)}}),Promise.all(e).then(()=>t)},u.prototype._setupNavigationListener=function(){this===i&&(this._popstateHandler=()=>{s=[],this.sync()},window.addEventListener("popstate",this._popstateHandler,!1))},u.prototype._isCurrentState=function(t){var e,r,i=this._activeState;return!!i&&(e=i,r=t,o.getUrlForRoutes([e])===o.getUrlForRoutes([r]))},u.prototype._getPendingState=function(t,e){var r,i=t.path,o=t.params||{};let n=this._routes.find(t=>t._match.test(i));return n&&n.redirect&&(i=n.redirect,n=this._getPendingState({path:i,params:o})),n?(r={path:i,params:o,detail:n.detail,pathParams:n.pathParams,redirect:n.redirect,_match:n._match},Object.freeze(r)):e&&(r={path:i,params:{},detail:{},pathParams:[]}),r},u.prototype._getRoutePathParams=function(t=""){const e=this._getPendingState({path:t});return e?e.pathParams:[]},u.prototype.createChildRouter=function(t,e={}){this._noHistory&&(e.history="skip");const r=this._activeState;if(!r)throw Error("Router("+this._name+") has no current state. Call sync() on the router first.");if(this._childRouter&&"skip"!==e.history)throw Error("Router("+this._name+") state("+r.path+") already has a child router");const i=new u(t,e,this);return this._childRouter=i,i},u.prototype.destroy=function(){this===i&&(window.removeEventListener("popstate",this._popstateHandler,!1),i=null)},u});
//# sourceMappingURL=ojcorerouter.js.map